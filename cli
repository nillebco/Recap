#!/bin/bash

# Recap macOS App Build Script
# This script handles building, running, testing, and archiving the Recap app

set -e  # Exit on any error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PROJECT_NAME="Recap"
SCHEME_NAME="Recap"
PROJECT_FILE="Recap.xcodeproj"
ARCHIVE_DIR="Archives"
ARCHIVE_NAME="Recap-$(date +%Y-%m-%d-%H-%M-%S).xcarchive"
DIST_DIR="dist"
BUNDLE_NAME="Recap-$(date +%Y-%m-%d-%H-%M-%S)"

# Resolve project root from this script's location (works from anywhere)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Locate the Xcode project file, even if it's within a subfolder like "Recap/"
resolve_project_file() {
    local start_dir="$1"
    local found_path=""

    # First, try within the script directory up to a few levels deep
    found_path=$(find "$start_dir" -maxdepth 3 -type d -name "$PROJECT_FILE" -print -quit 2>/dev/null || true)
    if [[ -n "$found_path" ]]; then
        echo "$found_path"
        return 0
    fi

    # Next, walk upwards and search shallowly in each ancestor
    local dir="$start_dir"
    while [[ "$dir" != "/" ]]; do
        found_path=$(find "$dir" -maxdepth 2 -type d -name "$PROJECT_FILE" -print -quit 2>/dev/null || true)
        if [[ -n "$found_path" ]]; then
            echo "$found_path"
            return 0
        fi
        dir="$(dirname "$dir")"
    done

    # Finally, try current working directory as a fallback
    found_path=$(find "$(pwd)" -maxdepth 3 -type d -name "$PROJECT_FILE" -print -quit 2>/dev/null || true)
    if [[ -n "$found_path" ]]; then
        echo "$found_path"
        return 0
    fi

    return 1
}

PROJECT_FILE_PATH="$(resolve_project_file "$SCRIPT_DIR" || true)"
if [[ -z "$PROJECT_FILE_PATH" ]]; then
    echo -e "\033[0;31m[ERROR]\033[0m Could not locate $PROJECT_FILE. Ensure it exists (e.g., Recap/$PROJECT_FILE)."
    exit 1
fi
PROJECT_ROOT="$(dirname "$PROJECT_FILE_PATH")"
cd "$PROJECT_ROOT"
PROJECT_FILE="$(basename "$PROJECT_FILE_PATH")"

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to check if Xcode is installed
check_xcode() {
    if ! command -v xcodebuild &> /dev/null; then
        print_error "Xcode command line tools not found. Please install Xcode and command line tools."
        exit 1
    fi
    print_success "Xcode command line tools found"
}

# Function to clean build folder
clean_build() {
    local configuration="${1:-Debug}"  # Optional argument, defaults to Debug
    print_status "Cleaning $configuration build folder..."
    xcodebuild clean -project "$PROJECT_FILE" -scheme "$SCHEME_NAME" -configuration $configuration
    print_success "$configuration Build folder cleaned"
}

# Function to build the app
build_app() {
    local configuration="${1:-Debug}"  # Optional argument, defaults to Debug

    print_status "Building $PROJECT_NAME with configuration $configuration..."
    xcodebuild build \
        -project "$PROJECT_FILE" \
        -scheme "$SCHEME_NAME" \
        -configuration "$configuration" \
        -destination "platform=macOS"
    print_success "$configuration Build completed successfully"
}

# Function to run the app
run_app() {
    local configuration="${1:-Debug}"  # Optional arg, defaults to Debug

    print_status "Running $PROJECT_NAME (configuration: $configuration)..."

    # Look for the app in DerivedData under the given configuration
    APP_PATH=$(find ~/Library/Developer/Xcode/DerivedData \
        -type d \
        -path "*/Build/Products/$configuration*/Recap.app" \
        -exec test -f {}/Contents/MacOS/Recap \; -print | head -1)

    # If no app found, build it first with the given configuration
    if [ -z "$APP_PATH" ]; then
        print_warning "No built app found. Building the app first..."
        build_app "$configuration"
        # Try to find the app again after building
        APP_PATH=$(find ~/Library/Developer/Xcode/DerivedData \
            -type d \
            -path "*/Build/Products/$configuration*/Recap.app" \
            -exec test -f {}/Contents/MacOS/Recap \; -print | head -1)

        if [ -z "$APP_PATH" ]; then
            print_error "Could not find built Recap.app even after building. Check build output for errors."
            exit 1
        fi
    fi

    print_status "Found app at: $APP_PATH"
    open "$APP_PATH"
    print_success "App launched successfully"
}

# Function to run tests
run_tests() {
    print_status "Running tests..."
    # Use the scheme's default test configuration (no hardcoded test plan)
    xcodebuild test -project "$PROJECT_FILE" -scheme "$SCHEME_NAME" -destination "platform=macOS"
    print_success "Tests completed successfully"
}

# Function to archive the app
archive_app() {
    print_status "Creating archive..."

    # Create archives directory if it doesn't exist
    mkdir -p "$ARCHIVE_DIR"

    # Archive the app
    xcodebuild archive \
        -project "$PROJECT_FILE" \
        -scheme "$SCHEME_NAME" \
        -configuration Release \
        -destination "platform=macOS" \
        -archivePath "$ARCHIVE_DIR/$ARCHIVE_NAME"

    print_success "Archive created: $ARCHIVE_DIR/$ARCHIVE_NAME"
}

# Function to create a redistributable bundle
bundle_app() {
    print_status "Creating redistributable bundle..."

    # Wipe out previous distributions
    if [ -d "$DIST_DIR" ]; then
        print_status "Cleaning previous distributions..."
        rm -rf "$DIST_DIR"
    fi

    # Create dist directory
    mkdir -p "$DIST_DIR"

    # First, create archive if it doesn't exist or is outdated
    if [ ! -d "$ARCHIVE_DIR/$ARCHIVE_NAME" ]; then
        print_status "Archive not found, creating one first..."
        archive_app
    fi

    # Export the archive to create the .app bundle
    print_status "Exporting application bundle..."

    # Create export options plist for ad-hoc distribution
    EXPORT_PLIST="$DIST_DIR/ExportOptions.plist"
    cat > "$EXPORT_PLIST" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>method</key>
    <string>mac-application</string>
    <key>destination</key>
    <string>export</string>
</dict>
</plist>
EOF

    # Export the archive
    xcodebuild -exportArchive \
        -archivePath "$ARCHIVE_DIR/$ARCHIVE_NAME" \
        -exportPath "$DIST_DIR/$BUNDLE_NAME" \
        -exportOptionsPlist "$EXPORT_PLIST"

    # Create the final distribution package
    BUNDLE_PATH="$DIST_DIR/$BUNDLE_NAME.zip"
    print_status "Creating distribution archive..."

    cd "$DIST_DIR/$BUNDLE_NAME"
    zip -r "../$BUNDLE_NAME.zip" . -x "*.DS_Store*" "__MACOSX*"
    cd "$PROJECT_ROOT"

    # Clean up intermediate files
    rm -rf "$DIST_DIR/$BUNDLE_NAME"
    rm -f "$EXPORT_PLIST"

    print_success "Redistributable bundle created: $BUNDLE_PATH"
    print_status "Bundle contents:"
    unzip -l "$BUNDLE_PATH"

    print_success "ðŸŽ‰ Distribution ready! Share $BUNDLE_NAME.zip with your friends!"
}

# Function to show help
show_help() {
    echo "Recap macOS App Build Script"
    echo ""
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  build     Build the app"
    echo "  run       Run the app"
    echo "  test      Run tests"
    echo "  archive   Create archive"
    echo "  bundle    Create redistributable bundle for sharing"
    echo "  all       Build, test, and archive (in that order)"
    echo "  clean     Clean build folder"
    echo "  help      Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 build"
    echo "  $0 bundle"
    echo "  $0 all"
    echo "  $0 clean && $0 build"
}

# Main script logic
main() {
    # We already cd'ed into project root; re-validate presence of project file
    if [ ! -d "$PROJECT_FILE" ] && [ ! -f "$PROJECT_FILE" ]; then
        print_error "Project file $PROJECT_FILE not found in $PROJECT_ROOT."
        exit 1
    fi

    # Check Xcode installation
    check_xcode

    # Parse command line arguments
    case "${1:-all}" in
        "build")
            clean_build ${@:2}
            build_app ${@:2}
            ;;
        "run")
            run_app ${@:2}
            ;;
        "test")
            run_tests
            ;;
        "archive")
            archive_app
            ;;
        "bundle")
            clean_build ${@:2}
            bundle_app
            ;;
        "all")
            clean_build ${@:2}
            build_app ${@:2}
            run_tests
            archive_app
            print_success "All operations completed successfully!"
            ;;
        "clean")
            clean_build ${@:2}
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
